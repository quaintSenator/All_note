# 前言
在AS2中我添加了一些个人的想法，而在本次作业中我将更加大胆地尝试新的内容。我们知道第三次作业的要求是渲染一直小奶牛。我的额外需求来自于，我在翻阅作业框架文件时发现model当中出现了后缀为3ds和blend的文件：
![](./markdown_pic/101asp17.png)
这应该是用3dsMax和blender做出的模型。import到3ds Max中就可以看到，的确是一些简单的建模。
![](./markdown_pic/101asp18.png)

因此，我设计了一个额外需求：自己使用上述建模软件捏一个模型，并用这段渲染程序来展示。

## 作业3 画奶牛 & 模型应用

### 前置知识回顾:布林冯模型
blinn-phong模型中的几个重要知识：

#### specular reflection
![](./markdown_pic/101asp19.png)
镜面反射中的重要概念是半程向量，由于v与l都是单位向量，他们直接相加再除以模就能得到所谓半程向量，这是一个指向两个向量**角平分线方向**的**单位向量**。
这里的镜面反射公式，采用了一个cos值来反应视线方向对于镜面反射的影响：如果半程向量h与法线几乎重合(夹角小 点积大)，那么显然v也与l的反射方向接近，从而能看到更强的高光反射。

这里的p次方，是为了强化这个余弦对于高光反射的干涉——只有相当靠近的夹角才能让人看到这个高光。一边p取5已经比较足够。
必须强调，布林冯模型是基于直观感受的、有一定科学性的模型，但显然其并不追求物理正确，甚至没有追求基础的能量守恒。

#### diffuse term
![](./markdown_pic/101asp21.png)

#### ambient term
![](./markdown_pic/101asp22.png)
这里的环境光是一个非常大胆的假设：所有点都有一个常数数值的基础光照。这显然是惊人的错误，但它确实很好用。

其中的ka、kd、ks，看起来是一个系数，但其实完全可以直接设计成一个Vector3f的颜色。对于RGB值分别进行同样的运算，得到的值再组合成一个变得比原本更暗(所有三种反射都会得到小于100%的k值)的颜色。
将所有三项加起来，就实现了布林冯光照模型。

### 前置知识回顾:逐顶点法线

为什么需要逐顶点求法线呢？
有时候我们会需要在每个顶点上都进行一次着色运算，而哪怕是布林冯模型，也必须得有着色点的法线n。
工业里的模型顶点会储存法线值。回到AS2当中，看一看Triangle.hpp就会发现，三角形Triangle类维护着一个Vector3f normal[3]。
此图展示了一种朴素的做法：把一个顶点相邻的若干三角形的法线平均。

![](./markdown_pic/101asp23.png)

### 作业要求
![](./markdown_pic/101asp16.png)

我们先把AS2的rasterize_triangle(const Triangle &t)拿过来：
```cpp
void rst::rasterizer::rasterize_triangle(Triangle &t)
{
    auto v = t.toVector4();
    float l = INT_MAX;
    float r = INT_MIN;
    float top = INT_MIN;
    float b = INT_MAX;
    for (auto k : v)
    {
        l = k.x() < l ? k.x() : l;
        r = k.x() > r ? k.x() : r;
        top = k.y() > top ? k.y() : top;
        b = k.y() < b ? k.y() : b;
    }

    for (int i = (int)l; i <= r; i++)
    {
        for (int j = (int)b; j <= top; j++)
        {
            float a[5]={0.25,0.25,0.75,0.75,0.25};
            float count=0;
            float min_z=INT_MAX;
            for(int k=0;k<=3;k++){
                float x=i+a[k];
                float y=j+a[k+1];
                if(insideTriangle(x,y,t.v)){
                    count+=0.25;
                    float tocul0=t.v[0].z();
                    float tocul1=t.v[1].z();
                    float tocul2=t.v[2].z();
                    float z_interpolation = my_interpolation(x,y,t,tocul0,tocul1,tocul2);
                    if(-z_interpolation<min_z)min_z=-z_interpolation;
                }
            }
            Eigen::Vector3f c0=t.getColor(0);
            Eigen::Vector3f c1=t.getColor(1);
            Eigen::Vector3f c2=t.getColor(2);

            float x=i+0.5;
            float y=j+0.5;
            float my_r=my_interpolation(x,y,t,c0.x(),c1.x(),c2.x());
            float my_g=my_interpolation(x,y,t,c0.y(),c1.y(),c2.y());
            float my_b=my_interpolation(x,y,t,c0.z(),c1.z(),c2.z());
  
            Eigen::Vector3f myColor((int)my_r*count,(int)my_g*count,(int)my_b*count);
                if(min_z<depth_buf[get_index(i,j)]){
                    depth_buf[get_index(i,j)]=min_z;
                    set_pixel(Eigen::Vector3f(i, j, 1), myColor);

                } 
            
                              
            
        }
    }
}

```

### 基础功能实践


### 提升需求1 颜色插值

### 提升需求2 MSAA
