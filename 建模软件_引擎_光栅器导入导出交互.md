# 建模软件 & 引擎 &  光栅器导入导出交互
## 前言
本笔记记录了我对如题三类软件中如何**交换资产**的探索。我们知道在游戏开发实际过程当中，艺术家呈递游戏物体的模型、纹理、动画等内容，这些内容将被导入到引擎里供进一步使用。

上述的三类软件，我使用的是：
建模软件(动画制作)：3dsMax
引擎： Unity
光栅器：opencv支持的渲染程序

其中提及光栅器是因为同时也在调试Games101网课的光栅器程序，其能够从一个相对底层的角度进行各种技术的底层尝试，因此如果能打通这个资产传递的三角，将会是一件非常有意义的事情。

## 3dsMax->Unity
我在3dsMax中做了一个小球下落的动画。
![](./markdown_pic/inNout2.jpg)
动画是游戏中最常用的一类资产之一。在企业工作流中，动画**从3dsMax等动画制作软件流向引擎**。
可以看到下图中各种导出格式。
![](./markdown_pic/inNout1.jpg)

回顾我们在Unity学习过程中使用的资产。这部分对应的工作在写作UnityAnimation.md当中。
[github - 我的UnityAnimation笔记](https://github.com/quaintSenator/All_note/UnityAnimation.md)

![](./markdown_pic/inNout3.jpg)
这里的人物静止、跳跃、跑步都是在UAS上获取的动画资源，这里以`.FBX`为后缀。

注意到，3dsMax的第一个导出选项就是`*.fbx`，然而两者的显著差距在于大小写。
我们直接按照一切默认配置export这个对象。
![](./markdown_pic/inNout4.jpg)

在Unity中`Assets`里选择`Import New Asset...`，选择之前生成的fbx文件后，在Assets文件夹中出现了如下资产：
![](./markdown_pic/inNout5.jpg)

参照我们在`UnityAnimation.md`当中记录的操作，把资产中的小球拖到场景里、将AnimationContoller绑定到小球上，而AC中的Clips是默认绑定好的，之后就可以运行看到效果了。

但是在运行时，这个动画的效果是不正确的。我们在3dsMax中设计的是按轨迹跳动直到不动的一个过程，而在Unity里小球仅弹跳一次，而后在直线上匀速移动。而且直接双击import设置以3d查看器查看的动画，这个动画几乎很难看出小球的高度衰减。

我重新export了一个3dsMax默认的茶壶，首先对于简单几何体fbx是完全可以一键import不出错的。之后我重新用自动生成关键帧生成了一个拖动茶壶并倒茶的动画。这次这个动画可以在3d查看器里正常播放。

这次Unity的动画显示也正常了。总结一下之前的问题：
获取import资产后，点击右侧小箭头展开其内容。一般的资产都至少会有一个Mesh和一个Clip。把Mesh拖到场景中，新建一个AC，那个Clip拖动到状态机页面，这会形成一个新的state。把这个state 连线到自身。而后，再把AC拖动到场景里的Mesh物体上，完成了全部的绑定。
**必须注意：**
*不要拖动import setting进入场景*

再重新制作一个之前的小球受阻力弹起运动的动画。这一次，可能是由于用到了父物体虚拟物体dummy，资产列表内是四个对象：

- import setting
- teapot001 
- teapot001(mesh)
- take001(clip)
![](./markdown_pic/inNout6.jpg)
其实下面的clip预览也可以看到，其实引入的动画是完全正确的。

这里的做法是这样的：
不要拖动Mesh，而是拖动Teapot001对象进入场景。这样做会在场景内形成一个父子对象：
![](./markdown_pic/inNout7.jpg)
之后将clip直接拖动到**父对象**上。（这会自动地生成一个AC，作为连接对象到动作的中介，相当于创建一个AC，设定一个clip对应状态，并将AC绑定到对象上）至此就可以在gameplay中看到正确的动画效果了。

概括：
1. **把资产中的对象/Mesh拖进场景。有对象时选择对象，否则选择Mesh。不要选择import setting。**
2. **直接把clip拖到scene当中的对象上。**

## 3dsMax->光栅器程序
首先我们来调研一下读取到的模型数据是什么样的。
![](./markdown_pic/inNout8.jpg)
从提取代码来看，`loader.LoadFile()`的参数是一个`*.obj`文件,有构成成员Loader.LoadedMeshes，这是一个顺序容器/数组，其中每个成员都被迭代器Mesh对应，而Mesh又有成员Vertices。

```
Vertices[0].Position.X
Vertices[0].Position.Y
Vertices[0].Position.Z
Vertices[0].Normal.X
Vertices[0].Normal.Y
Vertices[0].Normal.Z
Vertices[0].TextureCoordinate.X
Vertices[0].TextureCoordinate.Y
Vertices[0].TextureCoordinate.Z

Vertices[1]...
```
这个结构与我们在程序里设计的Triangle结构很像，而Triangle里还多一个`Vector3f color`

这段程序把Mesh当中的Vertices全部串联成三角形了。可以研究一下这段代码的逻辑：
```cpp
for(auto mesh : Loader.LoaderMeshes){
    for(int i=0;i<mesh.Vertices.size();i+=3){
        Triangle *t=new Triangle();
        for(int j=0;j<3;j++){
            t->setVertex(j,Vector4f(mesh.Vertices[i+j].Position.X,mesh.Vertices[i+j].Position.Y,mesh.Vertices[i+j].Position.Z,1.0));
            t->setNormal(j,Vector3f(Mesh.Vertices[i+j].Normal.X,Mesh.Vertices[i+j].Normal.Y,Mesh.Vertices[i+j].Normal.Z));
            t->setTexCoord(j,Vector2f(Mesh.Vertices[i+j].TexCoordinate.X,Mesh.Vertices[i+j].TexCoordinate.Y))
        }
        TriangleList.push_back(t);
    }
}
```
可以看出，Mesh.Vertices是一个充满了重复顶点的顶点数据集。
三角形和三角形之间是会有大量重复出现的顶点的，而在这个遍历过程中，我们可以看到i+j是只增不减的。进而言之，Mesh.Vertices的内容可能是：
```
V[0],V[1],V[2],
V[1],V[2],V[3],
V[4],V[5],V[6],
V[6],V[7],V[8],
...
```
需要注意，在Load完成之后，TriangleList当中的各个三角形顶点里的颜色数据都没有进行初始化。这里扯几句题外话。我们回顾一下几个shader，可以发现，texture_shader当中没有用到顶点颜色（这里也提示了一个问题，我编写的`rasterizer.cpp`在`rasterize_triangle()`中会无差别插值顶点各数值，包括顶点颜色，基本可以预料在texture模式下是0插0了）；phong_shader中，使用了payload当中的payload.color：
```cpp
Eigen::Vector3f kd=payload.color;//漫反射系数
```
这个数值是对像素所在三角形重心插值得来，但是我们知道三角形顶点的颜色其实是脏数据。

除了保存Mesh数据的`*.obj`文件，肯定还要以一种形式保存物体的颜色，无论是通过顶点颜色的模式还是纹理。我们看到后面几行：

```cpp
//...
std::string obj_path="../models/spots/"
auto texture_path="hmap.jpg"
r.set_texture(Texture(obj_path+texture_path));
```

也就是说，在这段光栅化程序里，我们读取的是`*.obj`格式的网格与 `*.jpg`格式的纹理数据。

首先我们来到3dsMax当中，看看export选项中有没有`*.obj`格式。
![](./markdown_pic/inNout1.jpg)
gw:OBJ-Exporter(*.obj)

那么这次我们做一个模型，在导出时把动画数据放弃掉，看看能得到什么。
![](./markdown_pic/inNout10.jpg)
我在3dsMax里拉了个茶壶，然后直接导出，选择obj导出项。
![](./markdown_pic/inNout11.jpg)
![](./markdown_pic/inNout12.jpg)
可以看到，这个输出当中是有一些四边形的。我立刻思考这样会不会造成什么后果。
我修改了loader文件名字符串，然后直接用phong模型运行。

报错。

我打开了3dsMax导出的`*.obj`文件。
```
#
# object Teapot001
#
...
v  12.7088 23.6493 -14.6701
v  12.4329 23.6493 -11.8593
v  -1.0867 24.5587 -0.9959
v  -1.0867 24.6193 -0.8439
v  -1.0867 24.5587 -0.6341
v  -1.0867 24.3768 -0.3897
v  -1.0867 24.0737 -0.1337
v  -1.0867 23.6493 0.1107
v  -4.1521 23.6493 -1.1506
v  -4.0355 24.0737 -1.3071
v  -3.9657 24.3768 -1.3392
...
vn -0.8494 0.4075 -0.3354
vn -0.7375 0.5589 -0.3791
vn -0.5768 0.7127 -0.3993
vn -0.4578 0.8196 0.3446
vn -0.5118 0.8591 0.0000
vn -0.3598 0.8896 0.2814
vn -0.4040 0.9148 0.0000
vn -0.2313 0.9554 0.1833
vn -0.2619 0.9651 0.0000
...
vt 0.8750 0.5500 0.0000
vt 0.8750 0.4750 0.0000
vt 0.8750 0.4000 0.0000
vt 0.7500 0.9250 0.0000
vt 0.7500 0.8500 0.0000
vt 0.7500 0.7750 0.0000
vt 0.7500 0.7000 0.0000
vt 0.7500 0.6250 0.0000
...
# 1034 texture coords

o Teapot001
g Teapot001
usemtl wire_198225087
s 2
f 1/1/1 2/2/2 3/3/3 4/4/4 
f 4/4/4 3/3/3 5/5/5 6/6/6 
f 6/6/6 5/5/5 7/7/7 8/8/8 
f 8/8/8 7/7/7 9/9/9 10/10/10 
f 10/10/10 9/9/9 11/11/11 12/12/12 
f 12/12/12 11/11/11 13/13/13 14/14/14 
f 14/14/14 13/13/13 15/15/15 16/16/16 
f 16/16/16 15/15/15 17/17/17 18/18/18 
f 2/2/2 19/19/19 20/20/20 3/3/3 
f 3/3/3 20/20/20 21/21/21 5/5/5 
f 5/5/5 21/21/21 22/22/22 7/7/7 
...
# 1984 polygons - 64 triangles
```

然后我又打开了我们原有的奶牛obj文件：

```
####
#
# OBJ File Generated by Meshlab
#
####
# Object spot_triangulated_good.obj
#
# Vertices: 3225
# Faces: 5856
#
####
vn 0.713667 0.093012 -0.694283
vt 0.854030 0.663650
v 0.348799 -0.334989 -0.083233
vn 0.742238 0.092067 0.663782
vt 0.724960 0.675077
v 0.313132 -0.399051 0.881192
vn 0.851635 0.494407 -0.174014
vt 0.892477 0.736968
...
vn 0.000000 0.299985 0.953944
vt 0.440532 0.261649
v 0.000000 -0.068825 1.048070
vn 0.000000 -0.945497 -0.325630
vt 0.476605 0.325877
v 0.000000 -0.095219 1.026420
# 3225 vertices, 0 vertices normals


f 739/739/739 735/735/735 736/736/736
f 189/189/189 736/736/736 735/735/735
f 192/192/192 738/738/738 737/737/737
f 739/739/739 737/737/737 738/738/738
f 190/190/190 741/741/741 740/740/740
f 743/743/743 740/740/740 741/741/741
f 736/736/736 189/189/189 743/743/743
f 742/742/742 743/743/743 189/189/189
f 745/745/745 747/747/747 191/191/191
f 744/744/744 191/191/191 747/747/747
f 746/746/746 747/747/747 190/190/190
f 741/741/741 190/190/190 747/747/747
...
# 5856 faces, 0 coords texture

# End of File
```

不可否认的是，这两侧的数据格式其实几乎是一样的，只不过在奶牛模型中，vn，vt和v三个数据被整合成一个组，一组一组地呈现，而新模型中则是分开罗列所有的vn，vt和v。

在我溯源LoadFile函数后，我发现事情变得复杂了起来。原作者实在是在OBJ_Loader.h当中写了太多的东西，整个文件来到了1000多行。我随即想到，与其去卒读这个令人头疼的代码，不如自己复习一下C++文件的知识，自己重写一个更短的Loader——毕竟这边obj的内容都已经一清二楚了。

### C++文件读取函数
![](./markdown_pic/inNout13.jpg)
简单写了一个C++文件读取程序。在整个过程中我们并不需要去修改提供的任何数据————光栅器程序是一个完全的读取-输出者，而不是改写者。

将中间的流处理语句改成一段字符串处理代码，即可完成对Mesh中vn，vt，v的抓取，他们的现实意义分别是法线normal，uv值和顶点坐标。