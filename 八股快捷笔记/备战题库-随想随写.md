# 备战题库
## C++
### 1.类详解与内存管理
#### 1.1 内存布局
1. 调用栈？调用一个函数的过程？
2. 内存结构，为什么要分区
3. 堆栈 text/bss/data段 堆和栈的区别 堆和栈是用什么数据结构存储的

静态变量和局部变量的不同，储存在哪


#### 1.2 类
构造函数有哪几类


#### 1.3 动态内存和智能指针
shared_ptr?
shared_ptr的实现机制
shared_ptr是线程安全的吗？
C++ new delete malloc free的区别? / new和malloc有什么区别?
![](./desktopic/question-5.jpg)
shared_ptr的计数器为0将指向的变量释放后，指向这个变量的weak_ptr怎么删除
   
#### 1.4 拷贝控制
拷贝构造函数为什么输入参数一般是常量

### 2.STL
1. map & unordered_map的底层
   map的底层是红黑树，而unordered_map的底层是哈希表。
2. stl 的容器线程安全吗
3. 
4. push_back、emplace_back区别；
   都是顺序容器共有的两个成员函数。在MSCV10编译体系下，push_back和emplace_back几乎没有差别；但是标准中的的push_back和emplace_back的区别在于，emplace_back在特定位置执行构造而非拷贝；
   以vector为例，push_back接收的参数是vector value_type的一个对象，调用后对其进行拷贝构造，拷贝到vector.end()位置；而emplace_back接受的参数是参数表，编译器拿到这些参数后会为他们匹配一个容器value_type的构造器，在容器vector.end()位置直接进行构造，而不必执行拷贝构造函数

5. 实现vector的拷贝构造函数
```cpp
std::map<int, Complicated> m;
int anInt = 4;
double aDouble = 5.0;
std::string aString = "C++";

// cross your finger so that the optimizer is really good
m.insert(std::make_pair(4, Complicated(anInt, aDouble, aString))); 

// should be easier for the optimizer
m.emplace(4, anInt, aDouble, aString);
```

你对STL的理解？
C++ vector resize & reverse;

如果Array已经到达其长度上限，继续push_back会发生什么？
   这是一道错题


### 3.面向对象特性
面向对象特性有哪些
多态、虚函数、虚函数表、虚指针
覆盖和重载的区别
### 4.大型项目
讲一讲static关键字的作用；
讲一讲const关键字的作用；

### 5.还未整理
Cpp的三大特性
c++11 新特性
c++ 四种cast
explicit关键字的作用是什么
左值和右值的区别是什么
空类的实例大小
虚函数机制
如何在C里面调用C++代码，反过来呢？
C和C++区别
vector和list的区别
reinterpret_cast的应用场景
dynamic_cast的实现机制
不用第三者交换两个数
内存泄漏
内存溢出


## 算法与数据结构
堆排序的原理
哈希冲突是什么，有哪些解决方法
判断两个树的对称
红黑树；和普通二叉搜索树以及AVL树对比
有效括号字符串
快排的最坏情况，最坏复杂度
哈希在插入元素的时候时间复杂度
哈希函数满足哪些特性？
有哪些常见的哈希函数？
图的遍历算法有哪几种？
dfs和bfs分别应用于哪种场景？
图的最短路径算法有哪些？
A*算法了解？
Top-k 最大堆
LIS，Longest Increasing Sequence,最长上升子序列问题


## 计算机网络
TCP和UDP的区别
游戏开发中基于UDP实现了KCP，如果是你来设计，如何保证其稳定？
三次握手和四次握手
time_wait状态为什么要等待2msl
在2msl之后一定会结束吗？
如果服务器断开连接会怎么样
三次握手如果第一次握手没有收到怎么办
UDP的传输内容限制多大
ping指令是应用在哪个协议下的
说说快速重传算法
TCP接收方收到的序号混乱或者有延迟会不会影响发送方
怎么实现可靠的UDP
套接字了解嘛，有用过这个编写程序吗
http和https的区别 https的加密方法、证书
DNS协议
select和epoll的区别
什么是网络流？
握手挥手过程中信号传输失败应该怎么处理


## 图形学

### 渲染管线和光栅化
1. 渲染管线的具体过程
![](./desktopic/question-1.jpg)

2. 一个**被前方物体遮挡住**的Fragment会不会被**着色**？
   一般情况下会的，所谓的片元Fragment是从几何着色阶段结束后，把所有三角形都给光栅化形成的，这个阶段尚未考虑到丢弃被遮住的片元，所以所有光栅化生成的，不论在前还是在后的片元都会运行片段着色器；只不过这些片段在后续的深度测试阶段将会被丢弃，从而不会真的绘制到屏幕的FrontBuffer里面。

   然而，现代GPU引入了一种新的特性叫做提前深度测试，这种特性提出，只要着色过程没有写入和修改任何深度值，就可以在光栅化后片段着色之前丢弃被遮住的片元、少运行一些FragmentShader，从而提升性能。
3. 什么是**深度冲突**，如何解决
   深度冲突发生于这种情况：一对三角形过于接近，而深度精度不足以分辨两者谁在前谁在后，从而不断争夺谁显示在前面。
   有几种思路来解决：
   一是避免把三角形放的过于接近，比如在紧紧贴合的两个面中间设置一个空气夹缝；
   二是提升深度精度，在openGL里默认是24位深度精度，但是在现代GPU中也支持32位，
   三是通过把near平面调的远一些来提升精度，因为深度-z函数约近的位置变化越快，精度越大。
### 图形学数学
4. 什么是**法线矩阵**，为什么要应用法线矩阵？

   法线矩阵是为了解决法向量在scale缩放操作中改变这个问题的。在平移和旋转，包括等比缩放当中，顶点法线都不会出错：平移对于顶点法线没有意义；对法向量旋转和旋转点一样只需要左乘旋转矩阵；等比缩放也一样。而**非等比缩放**将会导致前后**法向量出错**。
   
   比如我们对一批顶点引用一个模型变换矩阵model，我们很自然地想要为position和normal这两个量都左乘model。一般情况下，这样做都能奏效，得到正确的法线传递给fragment shader；但事实上model当中被一步非等比缩放**污染**了。
      ![](./desktopic/opengl-15.jpg)
   倘若直接传递，法线将会被扭曲，从而让最终的显示结果出问题。
   我们可以用一个简单的数学手段纠正之。

   法线矩阵可以很容易地从原本的模型矩阵model得到，即对其求逆-转置，再抹去第四维：
   ```
   mat3 normalMatrix = mat3(transpose(inverse(model)));
   ```
   这意味着对model先取反、再转置。
   我们知道，model可能是从三个矩阵得来的：平移矩阵transport, 旋转矩阵，缩放矩阵scale，model = transport * rotation * scale;

   另外需要注意，**求逆**是一个**高开销**运算，应当避免在着色器里使用。


2. 判断**点在三角形内**的方法 简单略
3. 给定入射方向和平面法线，求反射方向
   这个也还挺简单的，在glm里直接运用reflect函数，输入入射向量和法线即可得到出射向量；如果要手动求，如下图
   ![](./desktopic/question-3.jpg)
   参加了某厂笔试，这题也出现了，还是比较热门的简单题
4. 什么是四元数
### 光照

1. 什么是**Gouraud shading**
   是一种光照模型。我们常说的冯模型最初运行于顶点着色器上，也就是说光照结果将会直接存在顶点里、最后通过插值来反映在像素上。这让高光的范围扩大了许多、增强了许多，直观效果就是让图片变得很像塑料。当时这样做是为了降低开销，因为fragmentShader的运算次数要比VertexShader高的太多了。这种模型就是所谓的Gouraud模型。
   Phong shading并不比原先高档多少，仅仅是将光照运算放在片元着色器上。这让结果真实多了。
   ![](./desktopic/opengl-14.jpg)
2. shadow map当中，从光源出发位置得到的深度纹素，如何知晓它与摄像机位置渲染得到实际像素的对应关系？
   2-pass shadowmap当中，有一个概念叫光源坐标空间。我们把光源作为摄像机，输入lightpos，lightdir，lightup，即可用glm::LookAt()求出view矩阵；projection矩阵也是简单设置即可。这样一来，对所有三角形执行VP变换，被变换的点就成了光源坐标空间的点。
   ![](/desktopic/question-2.jpg)
   如图，在渲染点P的片段着色时，我们想决定其是不是在阴影中。首先，我们用VP变换把P变换到光源坐标空间去，这时候P的z值就是其到光源的距离；

   *然后我们根据P的x,y来查询深度纹理，要知道此时P的x，y就是这条射线对应深度纹素的uv值。我们用xy采样深度纹理，就得到了一个新的深度，对应图中的C。*
   ```hlsl
   float closestDepth = texture(shadowMap, projCoords.xy).r;
   float currentDepth = projCoords.z;
   float shadow = currentDepth > closestDepth  ? 1.0 : 0.0;
   ```
   如果C的depth和P的相等，那么说明这个物体被照亮；如果C的depth显著小于P的depth，那么我们知道P处在阴影当中。


3. 什么是环境光遮罩？什么是SSAO？
4. **帧缓冲**是用来解决什么问题的？
   有时候我们希望绘制一些东西，但不希望这些东西显示到屏幕上，而是先存留在某处，为之后在屏幕上绘制提供帮助。两个典型的帧缓冲案例是**阴影算法** 和 **后处理**。
   在这两个例子中，我们都是先不向最终画面(也就是默认帧缓冲的颜色纹理附件)绘制，而是定义一个新的帧缓冲，规定其附件，先绘制到这个帧缓冲的对应附件上(阴影算法shadowmap是绘制到深度附件，而后处理是绘制到颜色附件)

   同时，在帧缓冲技术之外我们还提出了交换链技术，也就是当前显示的frame称为frontbuffer，而我们总是计算另一个称为backbuffer的帧来供下一帧展示

5. **模板缓冲/模板测试**是用来解决什么问题？
   模板缓冲就是用来做模板测试的， 我们知道一般绘制时，为了绘制一个fragment，总是先执行深度测试以判断当前fragment究竟是否要绘制，毕竟被遮挡的fragment本不该绘制。而模板测试发生在深度测试之前，用于完成一些更精细的操作。
   模板测试的逻辑是需要自己修改以配合的，如果我们不干预模板测试，默认的模板测试函数是GL_ALWAYS，表示任何fragment都能通过模板测试，而不会被蒙蔽(masked)。需要指出，模板测试和深度测试是相互辅助的，又由于可以自己编写逻辑，灵活性很强
   运用模板测试的两个简单例子：

   1. 管中窥豹 我们可以假设我们的游戏人物正通过一个望远镜观察世界，他能看到的只是屏幕中心一个圆形的区域。这里我们就可以先在屏幕上绘制一个圆形，被绘制的片元在绘制时候把模板置为1：
   ```cpp
   //glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)
   //sfail: stencil失败执行的行动
   //dpfail: stencil成功，但depth失败执行的行动
   //dppass: 均成功时候执行的行动
   //这样设计参数是为了两个模板一旦有一个失败就不必继续测下一项了，直接剔除frag即可
   glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);

   //通过这样的设计，我们要求在模板和深度都通过的时候，
   //将模板值设置为glStencilFunc函数设置的ref值，见下面的glStencilFunc
   ```
   而后我们draw第二次，这里的draw这样设定：
   ```cpp
   //glStencilFunc(GLenum func, GLint ref, GLuint mask)
   glStencilFunc(GL_EQUAL, 1, 0xFF)//只有=1的模板能够通过测试
   ```
   这样我们的模板测试总是把当前位于0xFF（全1）做and运算，只有等于(GL_EQUAL)1才能通过测试。

   2. 物体轮廓 同上，第一遍渲染的模板测试策略是：
   ```cpp
   glStencilFunc(GL_ALWAYS, 1, 0xFF);
   glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
   //凡是fragment均通过，但通过后必须把模板置为1
   ```
   渲染采用真实shader；
   
   二次渲染之前将物体scale 1.05，放大一些；
   禁用深度测试(这会造成绘制采用画家算法，后来居上，总是覆盖之前的内容)
   第二次渲染将采用纯色shader，也就是绘制外框的shader
   第二遍渲染的策略是：
   ```cpp
   glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
   glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
   //注意，屏幕上有三类frag
   //没有frag的位置，本来就不会进行两种test，也不会有绘制；
   //有frag，且mask=1的位置，就是我们之前绘制了物体的位置，此时那里已经变成了真实物体的颜色，我们不会进行覆写
   //有frag，且mask！=1的位置，这说明是我们的放大使其出现在屏幕中，也就是我们要找的轮廓了，进行渲染，输出纯色
   ```
   6. HDR是什么，解决什么问题？
   HDR，High Dynamic Range, 高动态范围，相对于HDR还有 LDR，低动态范围。这两个名词都是用来指代色域的，也就是屏幕上的颜色能够允许的范围。
   我们知道，显示器对于一个像素的显示，亮度上限是255,255,255,也可以用三个[0, 1]的浮点数来记录。那么如果局部点的亮度超过了1，我们的显示器却不能显示超过1的值，最后就导致画面中呈现出一大片白色，这片白色本身可能是一扇窗户、一个被照亮的物体，但结果是一大片白色让大家看不出任何东西，也就是"loss of detail"
   ![](./desktopic/question-4.jpg)
   我们可以通过**色域映射**来解决这个问题。色域映射的核心思想就是允许某一个点的颜色通道值超过1，也即把[0, x]的颜色通道值映射到[0, 1], 但这种映射显然不是一个简单的映射算式就可以完成的。比如我们想一想，在一个昏暗的场景，也许大多数颜色都不大于0.3，而突然游戏人物从室内走到室外，现在这些颜色一下到达了20多，如果采用同一套算法进行色域映射，前者将暗得无法接受。
   同时，色域映射一定是需要把整个屏幕的信息纳入计算的，而非在一个fragmentshader就可以完成。

   
   
### 采样
1.  你所知道的AA算法？

### 其他
1. D3D 和 ogl的区别？

D3D似乎不开源
1. 什么是交换链，为什么要引入交换链？

明日方舟狮蝎的技能会高出地表怎么从渲染层面解决
璃月看到龙脊雪山怎么渲染
NPC太


## 计算机组成原理&操作系统
### 1 进程和线程
同一个进程的线程之间共享哪些，不共享哪些
线程同步有哪些方法
进程调度有哪些算法
给你个指向共享内存的指针，多个线程共享这个队列，如何做
进程和线程的区别？
进程通信的方法？
命名管道和匿名管道的区别
CPU调度算法
物理地址到逻辑地址之间是怎么转换的
多线程一致性如何保持

### 2 内存管理
内存分页了解吗，置换有哪些算法
分页和分段的区别
虚拟内存和物理内存
虚拟内存？

### 3 编译
编译过程，链接是干什么的，动态链接和静态链接
什么函数可以在main之前运行
`#ifdef` 这是什么作用

### 4 尚未整理
1.讲一讲虚拟内存
2.内存虚拟内存之间是怎么调度的
3.页地址是怎么查询到物理地址的
4.页表到实际物理地址的实现设计什么数据结构（我答了个map的映射关系，不知道对不对）

## 实践题

有一个生成[0,1]随机数的函数，把A块钱分给B个人。尽量少调用方法


五层内的树的任何结点都可以用一个三位数表示，比如321，表示第三层第二个节点，其value是1。任务就给个数组包含很多这样的三位数，然后你去求得从树根到树叶的最小路径

1. 一个圆形区域随机空投等概率
这个蛮简单的，极坐标，分别随机生成半径和角度

1. 1 * 2的地砖，铺满2 * n的空间，几种不同的方法
N个方块，组成一个金字塔（下一层的方块数要多于上一层），几种不同的方案

leetcode249 移位字符串分组

给定数组输出第k小子序列和

1代表陆地，0代表海洋，查找陆地形状不同的数量，（通过旋转等变换能相同的视为不同形状）
输入：
11000
10000
00001
00011
输出：2

给定一个 长度为 n 的整型数组 nums 和一个数值 k ，返回第 k 小的子序列和。



AB抛硬币，先抛到正面的人赢，问A赢的概率
链表倒数第K个节点

赛马，25匹马，5个一组赛跑。最少比几次找到前三快的。。（最后我提出的方案是模仿某一种排序，忘了名字了，5x5的格子，找中位数然后缩小范围。。先比5次，再中位数比1次

那些排序是稳定的？

数组全排列
动态规划实现原理
treemap原理
并查集
洗牌算法 时间复杂度
分治法的实现原理
arraylist的长度扩展
求二叉树的宽度
upper_bound
最小生成树
链表和数组的优劣
寻路算法
递归的底层是怎么实现的？使用栈的过程？
链式结构顺序结构的差异


static_cast dynamic_cast
extern关键字，extern C
手写代码strncpy
malloc和new的区别
C++的static_cast和dynamic_cast的区别
a++为什么不是线程安全？ a++翻译成汇编是什么能写出来吗？
**static数据和基本数据区别**
**把vector a赋值给b，修改a是否会影响b的内容？这种赋值是传递引用吗？**
vector中能传引用吗，底层实现原理（两倍扩容）
STL vector底层，push_back()会发生什么
什么情况会导致栈溢出
一个函数编译的时候是怎么转化为汇编语言的 比如 int add(int a,int b)
多继承的两个子类都实现了一同名函数，具体会调用那个
参数传递的底层过程
重载和重写
重载运算符，代码示例

- 经典八股
C++和C#的区别？
C#没有指针，如何管理内存？
讲讲看List容器和Vector容器的差别？
new 的用法，一个new的对象内存如果不回收会怎样？
智能指针了解如何？
public，private，protected各自的权限范围，有没有例外(友元）
map的底层？
~~红黑树？~~
~~虚函数、虚表？~~
32位浮点数的结构？
struct 和 class的区别？
用过哪些设计模式？

- 图形学
有无实时渲染项目经历
Unity Shader里面顶点着色器和像素着色器的输入输出分别是？
像素着色器的输出除了颜色还有什么？
z值的作用？
