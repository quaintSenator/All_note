# 
## TCP和UDP

## 帧同步和状态同步
帧同步和状态同步是实现网游的最基本的两种通讯同步原则，一款网络游戏或者是帧同步的，或者是状态同步的。

有句话说得好：在设计一款网络游戏时，首先应该考虑这款游戏能不能使用帧同步。如不适合采用帧同步，那么就实现状态同步。

帧同步的特点是：
1. 客户端按照特定的帧率采集玩家操作，并将操作转发给服务端
2. 服务端收到所有玩家的指令，全部集中起来，再广播给所有玩家的客户端
3. 客户端收到了一帧时间内所有玩家的操作，分别在本地演算操作结果并重现游戏世界

假设这是一局两人的英雄联盟游戏：
t1:盲僧向提莫位置发射天音波，即盲僧鼠标指向提莫位置并按下Q键；与此同时提莫正在向下走位
t1:盲僧和提莫的客户端分别采集到上述信息，并发送给了服务端
t2:盲僧和提莫发送的操作帧到达了服务端(虽然略有先后，但几乎是同时抵达)，服务端把这样的包封装好：[玩家1 Q 鼠标坐标 x1y1 玩家2 右键 鼠标坐标x2y2]，然后广播给所有的玩家
t3:盲僧和提莫的客户端都接到了服务器公证的t2帧信息，他们各自演算并绘制了游戏世界：盲僧抬手放出天音波，而提莫移动到了另一个位置


### 定时不等待/乐观lockstep
最典型的帧同步实践：[知乎 曾志伟 【网络同步】浅析帧同步和状态同步](https://zhuanlan.zhihu.com/p/357973435)

1. 单个用户当前键盘上下左右攻击跳跃是否按下用一个32位整数(mask)描述，服务端描述一局游戏中最多8玩家的键盘操作为：int player_keyboards[8];
2. 服务端每秒钟20-50次向所有客户端发送更新消息（包含所有客户端的操作和递增的帧号）：
3. update=（FrameID，player_keyboards）
4. 客户端就像播放游戏录像一样不停的播放这些包含每帧所有玩家操作的 update消息。
5. 客户端如果没有update数据了，就必须等待，直到有新的数据到来。
6. 客户端如果一下子收到很多连续的update，则快进播放。
7. 客户端只有按键按下或者放开，就会发送消息给服务端（而不是到每帧开始才采集键盘），消息只包含一个整数。服务端收到以后，改写player_keyboards

### 帧同步的优缺点
帧同步最大的好处是几乎不可能**出错**，客户端-服务端的模式保证了唯一的输入带来唯一确定的结果。这在各种电子竞技里大放异彩，职业选手们能够打出无比精彩的操作，而没有机会把渣操甩锅给程序的错误执行，尤其是在赛场采用稳定的网络连接时，职业选手的操作将100%地绝不出错绝不延迟地展现在游戏世界里。

由于帧同步的设计指出，服务器仅仅起到一个转发报文的功能，因此有许多针对帧同步设计**外挂**的思路：
1. 既然客户端能够收到所有人在一帧内的操作，那么英雄联盟的战争迷雾、CSGO的墙体遮蔽事实上都可以轻松地克服，只要修改客户端程序，让客户端在复现自己操作的同时也复现其他人的操作，就能实现开图或者透视；
2. 既然由客户端发出操作，那么事实上可以通过辅助程序来代替人操作，从而编写出人在物理上无法做到的虚假操作来欺骗客户端，这种外挂一般被认为是脚本，比如说英雄联盟的脚本能够在很短的时间内读取屏幕、发现弹体，然后在一个逻辑帧的时间里向服务端发出走位指令，从而使作弊者几乎不会被任何技能命中。这样的程序在CSGO中也就是自瞄，玩家的准星总是能在一帧时间内从屏幕任何地方瞬间拉动到刚刚出现在屏幕上的敌人的头上。

此外，因为要对客户端进行高频的往返通讯，所以玩家众多的游戏并不适合帧同步，比如MMO热衷的万人同屏，如果上万人都对服务器发送报文，无疑也是一场灾难。哪怕是近年风靡的大逃杀游戏，比如PUBG等，倘若真的要支撑100人的帧同步就已经相当头疼了，因此PUBG事实上采取了状态同步。

还有一个问题是不同机器的**浮点精度**有差异。如果夸张一些的说，一个游戏人物的移动速度是1.4832，在一些机器上则因为精度不足被存储为1.48,这样一来，A选择阿卡丽，在英雄联盟里的第一个逻辑帧就点击中路出门上线，而后挂机去尿尿等着英雄走到中路，这样一来20帧后A的机器运算出走动的距离和B的机器运算的结果就差了6.4个单位。两个机器上阿卡丽的位置是不同的，这将造成灾难。

