# Unity & NGUI

## UI美术资源应该导入到哪里
对于传统Unity开发流程，一般需要强调，UI美术资源放在Resources/UI文件夹下，这样做主要是考虑到Unity动态资源加载会从Resources文件夹中读取内容(Resources.Load)。Resources文件夹中的所有资源全都会被打包。

近年来，游戏内容普遍地增大，游戏占用的硬盘空间也日渐成为玩家更加关心的重要性能参数。Resources中的全部资源都会打包，这一点要求我们不能无分辨地将UI美术资源全部堆放在Resources当中。我初步考虑到两个情况：
第一，游戏在多语言环境下发布。多语言问题在大多数情况下是由程序考虑的：一段需要输出到View的文字应当通过语言层处理，转移到不同的具体语言版本。但很多UI上的文字具有复杂的美术效果，此时每一种语言的美术资源都需要制作到游戏资源中。如果希望将这些美术资源放在Resources文件夹内，应当考虑将不同语言的版本分别打成不同的包，而不是丢在同一个版本的发布包体中。

第二，在线资源。有时候项目中使用的美术资源实在太多，一种技术方案提出，将部分美术资源放在服务器上，提供特定的协议用以查询。这类资源不必存放在包体中，节省了大小，但服务器必须额外处理这些查询图片资源的负载。这些图片一经使用就可以藏匿在用户的本地文件中，应当提供代码逻辑，在用户再次需要这个图片的时候前往特定本地路径获取，用一次读硬盘代替一次web request。


## UIAtlas
### What's Atlas
统一语言，在Unity中这一概念被称为Sprite Atlas，其被设计出来就是为了解决**one Texture one Drawcall**问题的。在UI这个领域上，大多数UI组件都是被2D地绘制到屏幕上，在这个过程中任何一张纹理资源被绘制到屏幕上的某个位置都需要一次DrawCall，即CPU通知GPU需要绘制-GPU向FrameBuffer中绘制。这个过程比程序执行这样纯CPU的过程更为耗时，因此减Drawcall成为游戏UI开发最重要的任务之一。

在UI系统的某一时刻，用户屏幕上显示的若干东西都应该尽可能来自一批图片资源，这些图片资源被整合成一张大图，CPU用一次Drawcall告诉GPU若干个子图位置，GPU在一次绘制中将大图上的若干个小图分别绘制到FrameBuffer的不同位置，这就是图集的工作原理。

[CSDN-blog 使用和不使用图集在Unity中drawcall对比](https://blog.csdn.net/xhxx_/article/details/133134367)

在NGUI中，图集对应UIAtlas组件；且在更为广义的语境下，图集也应当是一个针对UI提出的概念。后续将把这个概念称为UI图集。

### Build and Edit
NGUI提供了Atlas Maker来制作和修改图集，选择一个已有的图集，在Atlas Maker中打开，
